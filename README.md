# Transfer Service

Сервис для управления пользователями и выполнения денежных переводов между их аккаунтами. Реализована бизнес-логика перевода, аутентификация, а также интеграционные тесты с использованием Testcontainers.

---

## Запуск проекта

Для локального запуска требуется установленный **Docker** и **Docker Compose**.

### Шаги для запуска:

1. Необходимо клонировать текущий репозиторий:
    ```bash
    git clone git@github.com:Arrkadique/transfer-service.git
    cd transfer-service
    ```

2. Запуск приложения с помощью Docker Compose (нужны root права, я работаю на ubuntu, поэтому sudo):
    ```bash
    sudo docker compose up --build
    ```

3. Приложение будет доступно на [http://localhost:8080](http://localhost:8080).

4. Swagger API доступен по адресу: [http://localhost:8080/swagger-ui.html](http://localhost:8080/swagger-ui.html)

---

## Стек технологий

**Backend:**

- Java 17
- Spring Boot
    - Spring Web
    - Spring Data JPA
    - Spring Security (с JWT)
- PostgreSQL
- Liquibase
- Testcontainers
- JUnit, Mockito

**Инструменты:**

- Docker и Docker Compose
- Lombok
- MapStruct
- Swagger

---

## Описание логики и принятых решений

### 1. Аутентификация и авторизация

- Реализовал аутентификация через JWT.
- При успешном логине пользователь получает токен, который должен использоваться в заголовках других запросов:
    ```bash
    Authorization: Bearer <token>
    ```

### 2. Переводы между аккаунтами

При переводе система валидирует:

- Достаточность баланса отправителя.
- Корректность указанных аккаунтов.

Использовал аннотацию `@Transactional` и пессимистичные блокировки для обеспечения целостности транзакции перевода.

### 3. Миграции Liquibase

- Все изменения схемы хранятся в `src/main/resources/db/changelog`.
- При старте приложения миграции автоматически применяются.

### 4. Интеграционные тесты

- Для API-покрытия использовал MockMvc.
- Контейнер PostgreSQL разворачивал с помощью Testcontainers.
- В контейнера использовал аннотацию `@DynamicPropertySource`, чтобы подключать параметры базы из контейнера. (В идеале вынести все подобные настройки в конфигурационный файл для test профиля)

---

## Не обязательные фичи

### 1. Добавлен swagger
### 2. Добавлено логирование с помощью Slf4j

(В идеале использовать тот же ELK, но в контексте этой задачи обычного логирования будет достаточно)

### 3. Добавлено кэширование

Кэшируется метод для получения пользователей. На проектах для данных целей использовал Redis. Просто поднять instance и добавить конфиги.
